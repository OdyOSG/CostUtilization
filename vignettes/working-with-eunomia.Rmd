---
title: "Working with Eunomia Test Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with Eunomia Test Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  message = FALSE,
  warning = FALSE,
  eval = FALSE
)
```

## Introduction

This vignette demonstrates how to use the CostUtilization package with Eunomia, OHDSI's synthetic test dataset. Since Eunomia doesn't include cost data by default, the package provides helper functions to inject synthetic cost data for testing and development purposes.

## Understanding Eunomia

Eunomia is a standardized, open-source dataset containing synthetic patient data in OMOP CDM format. It's perfect for:

- Testing and development
- Creating reproducible examples
- Learning OHDSI tools
- Demonstrating analyses

```{r setup}
library(CostUtilization)
library(DatabaseConnector)
library(dplyr)
library(cli)

# Check if Eunomia is installed
if (!requireNamespace("Eunomia", quietly = TRUE)) {
  cli::cli_alert_warning("Installing Eunomia package...")
  install.packages("Eunomia")
}

library(Eunomia)
```

## Setting Up Eunomia with Cost Data

### Step 1: Connect to Eunomia

```{r connect}
# Get connection details for Eunomia
connectionDetails <- Eunomia::getEunomiaConnectionDetails()

# Connect to the database
connection <- DatabaseConnector::connect(connectionDetails)

# Verify connection
cli::cli_alert_success("Connected to Eunomia database")

# Check available tables
tables <- DatabaseConnector::getTableNames(connection, "main")
cli::cli_h3("Available tables in Eunomia:")
print(sort(tables))
```

### Step 2: Inject Synthetic Cost Data

The `injectCostData` function creates synthetic payer plan periods and cost records:

```{r inject-cost}
# Inject cost data with default settings
cli::cli_h2("Injecting synthetic cost data")

injectCostData(
  connection = connection,
  cdmDatabaseSchema = "main",
  costDomains = c("Procedure", "Measurement", "Visit", "Device", "Drug", "Observation", "Condition"),
  seed = 123  # For reproducibility
)

# Verify cost table creation
costCount <- DatabaseConnector::querySql(
  connection,
  "SELECT COUNT(*) AS n FROM main.cost"
)
cli::cli_alert_info("Created {costCount$n} cost records")

# Check payer plan periods
payerCount <- DatabaseConnector::querySql(
  connection,
  "SELECT COUNT(*) AS n FROM main.payer_plan_period"
)
cli::cli_alert_info("Created {payerCount$n} payer plan periods")
```

### Step 3: Transform to CDM v5.4+ Format

The cost table needs to be in the long format introduced in CDM v5.4:

```{r transform-cost}
# Transform cost table to v5.4+ format
cli::cli_h2("Transforming cost table to CDM v5.4+ format")

transformCostToCdmV5dot4(
  connectionDetails = connectionDetails,
  cdmDatabaseSchema = "main",
  createIndexes = TRUE
)

# Verify transformation
costStructure <- DatabaseConnector::querySql(
  connection,
  "PRAGMA table_info(cost)"
)

cli::cli_h3("New cost table structure:")
print(costStructure |> select(name, type))
```

## Exploring the Synthetic Cost Data

### Understanding Payer Plans

```{r explore-payers}
# Examine payer plan distribution
payerPlans <- DatabaseConnector::querySql(connection, "
  SELECT 
    payer_source_value,
    plan_source_value,
    COUNT(*) AS n_periods,
    COUNT(DISTINCT person_id) AS n_persons
  FROM main.payer_plan_period
  GROUP BY payer_source_value, plan_source_value
  ORDER BY n_periods DESC
") |>
  rename_with(tolower)

cli::cli_h3("Payer plan distribution:")
print(payerPlans)

# Check plan duration statistics
planDurations <- DatabaseConnector::querySql(connection, "
  SELECT 
    AVG(JULIANDAY(payer_plan_period_end_date) - JULIANDAY(payer_plan_period_start_date)) AS avg_duration_days,
    MIN(JULIANDAY(payer_plan_period_end_date) - JULIANDAY(payer_plan_period_start_date)) AS min_duration_days,
    MAX(JULIANDAY(payer_plan_period_end_date) - JULIANDAY(payer_plan_period_start_date)) AS max_duration_days
  FROM main.payer_plan_period
") |>
  rename_with(tolower)

cli::cli_h3("Plan duration statistics:")
print(planDurations)
```

### Understanding Cost Distribution

```{r explore-costs}
# Analyze cost distribution by domain
costByDomain <- DatabaseConnector::querySql(connection, "
  SELECT 
    cost_domain_id,
    COUNT(*) AS n_records,
    COUNT(DISTINCT cost_event_id) AS n_events,
    AVG(cost) AS avg_cost,
    MIN(cost) AS min_cost,
    MAX(cost) AS max_cost
  FROM main.cost
  WHERE cost_concept_id = 31978  -- Total charge
  GROUP BY cost_domain_id
  ORDER BY n_records DESC
") |>
  rename_with(tolower)

cli::cli_h3("Cost distribution by domain:")
print(costByDomain)

# Analyze cost types
costTypes <- DatabaseConnector::querySql(connection, "
  SELECT 
    c.cost_concept_id,
    con.concept_name,
    COUNT(*) AS n_records,
    AVG(c.cost) AS avg_cost
  FROM main.cost c
  LEFT JOIN main.concept con ON c.cost_concept_id = con.concept_id
  GROUP BY c.cost_concept_id, con.concept_name
  ORDER BY n_records DESC
") |>
  rename_with(tolower)

cli::cli_h3("Cost types in the data:")
print(costTypes)
```

## Running Cost Analyses on Eunomia

### Example 1: Basic Cohort Cost Analysis

```{r basic-analysis}
# Create a cohort of patients with gastrointestinal bleeding
# (This is one of the example cohorts in Eunomia)
DatabaseConnector::executeSql(connection, "
  CREATE TABLE main.gi_bleed_cohort AS
  SELECT DISTINCT
    1 AS cohort_definition_id,
    person_id AS subject_id,
    condition_start_date AS cohort_start_date,
    COALESCE(condition_end_date, DATE(condition_start_date, '+30 days')) AS cohort_end_date
  FROM main.condition_occurrence
  WHERE condition_concept_id IN (192671, 4112343)  -- GI bleeding concepts
")

cohortSize <- DatabaseConnector::querySql(
  connection,
  "SELECT COUNT(DISTINCT subject_id) AS n FROM main.gi_bleed_cohort"
)
cli::cli_alert_info("Created GI bleeding cohort with {cohortSize$n} patients")

# Analyze costs for this cohort
giBleedCosts <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "gi_bleed_cohort",
  cohortId = 1,
  anchorCol = "cohort_start_date",
  startOffsetDays = -30,   # 30 days before
  endOffsetDays = 90,      # 90 days after
  verbose = TRUE
)

cli::cli_h3("GI Bleeding Cost Analysis Results:")
print(giBleedCosts)
```

### Example 2: Comparing Drug Costs

```{r drug-costs}
# Create cohorts for different drug exposures
# Celecoxib users
DatabaseConnector::executeSql(connection, "
  CREATE TABLE main.drug_cohorts AS
  SELECT 
    1 AS cohort_definition_id,
    person_id AS subject_id,
    MIN(drug_exposure_start_date) AS cohort_start_date,
    MAX(drug_exposure_end_date) AS cohort_end_date
  FROM main.drug_exposure
  WHERE drug_concept_id = 1118084  -- Celecoxib
  GROUP BY person_id
")

# Diclofenac users
DatabaseConnector::executeSql(connection, "
  INSERT INTO main.drug_cohorts
  SELECT 
    2 AS cohort_definition_id,
    person_id AS subject_id,
    MIN(drug_exposure_start_date) AS cohort_start_date,
    MAX(drug_exposure_end_date) AS cohort_end_date
  FROM main.drug_exposure
  WHERE drug_concept_id = 1124300  -- Diclofenac
  GROUP BY person_id
")

# Compare costs between drug cohorts
drugCostComparison <- map_dfr(1:2, function(cohortId) {
  
  result <- calculateCostOfCare(
    connection = connection,
    cdmDatabaseSchema = "main",
    cohortDatabaseSchema = "main",
    cohortTable = "drug_cohorts",
    cohortId = cohortId,
    anchorCol = "cohort_start_date",
    startOffsetDays = 0,
    endOffsetDays = 180,
    verbose = FALSE
  )
  
  result |>
    mutate(
      cohortId = cohortId,
      drugName = ifelse(cohortId == 1, "Celecoxib", "Diclofenac")
    )
})

cli::cli_h3("Drug Cost Comparison:")
print(drugCostComparison |> select(drugName, total_cost, cost_pppm, visits_per_1000_py))
```

### Example 3: Event-Specific Costs

```{r event-costs}
# Define event filters for GI-related procedures and medications
giEventFilters <- list(
  list(
    name = "GI Procedures",
    domain = "Procedure",
    conceptIds = c(4301351, 4142875, 4143316)  # Endoscopy procedures
  ),
  list(
    name = "GI Medications", 
    domain = "Drug",
    conceptIds = c(923645, 19059410, 40165636)  # PPIs, H2 blockers
  ),
  list(
    name = "GI Labs",
    domain = "Measurement",
    conceptIds = c(3016723, 3013721)  # Hemoglobin, hematocrit
  )
)

# Analyze GI-specific costs
giSpecificCosts <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "gi_bleed_cohort",
  cohortId = 1,
  anchorCol = "cohort_start_date",
  startOffsetDays = -7,
  endOffsetDays = 30,
  eventFilters = giEventFilters,
  returnFormat = "list",
  verbose = TRUE
)

cli::cli_h3("GI-Specific Cost Results:")
print(giSpecificCosts$results)

cli::cli_h3("Diagnostic Information:")
print(giSpecificCosts$diagnostics)
```

## Validating Synthetic Data

### Check Data Quality

```{r validate-data}
# Verify cost data completeness
costCompleteness <- DatabaseConnector::querySql(connection, "
  SELECT 
    'Total Records' AS metric,
    COUNT(*) AS value
  FROM main.cost
  UNION ALL
  SELECT 
    'Records with NULL cost',
    COUNT(*)
  FROM main.cost
  WHERE cost IS NULL
  UNION ALL
  SELECT 
    'Records with zero cost',
    COUNT(*)
  FROM main.cost
  WHERE cost = 0
  UNION ALL
  SELECT 
    'Unique persons with costs',
    COUNT(DISTINCT person_id)
  FROM main.cost
  UNION ALL
  SELECT 
    'Unique cost events',
    COUNT(DISTINCT cost_event_id || '-' || cost_domain_id)
  FROM main.cost
") |>
  rename_with(tolower)

cli::cli_h3("Cost data quality metrics:")
print(costCompleteness)

# Check temporal coverage
temporalCoverage <- DatabaseConnector::querySql(connection, "
  SELECT 
    MIN(incurred_date) AS earliest_cost,
    MAX(incurred_date) AS latest_cost,
    COUNT(DISTINCT DATE(incurred_date, 'start of month')) AS n_months
  FROM main.cost
  WHERE incurred_date IS NOT NULL
") |>
  rename_with(tolower)

cli::cli_h3("Temporal coverage of cost data:")
print(temporalCoverage)
```

### Verify Realistic Patterns

```{r verify-patterns}
# Check cost patterns by visit type
visitCostPatterns <- DatabaseConnector::querySql(connection, "
  SELECT 
    v.visit_concept_id,
    vc.concept_name AS visit_type,
    COUNT(DISTINCT v.visit_occurrence_id) AS n_visits,
    AVG(c.cost) AS avg_cost,
    STDDEV(c.cost) AS std_cost
  FROM main.visit_occurrence v
  JOIN main.cost c ON v.visit_occurrence_id = c.cost_event_id 
    AND c.cost_domain_id = 'Visit'
  LEFT JOIN main.concept vc ON v.visit_concept_id = vc.concept_id
  WHERE c.cost_concept_id = 31978  -- Total charge
  GROUP BY v.visit_concept_id, vc.concept_name
  ORDER BY n_visits DESC
  LIMIT 10
") |>
  rename_with(tolower)

cli::cli_h3("Cost patterns by visit type:")
print(visitCostPatterns)

# Verify payer coverage patterns
payerCoverage <- DatabaseConnector::querySql(connection, "
  SELECT 
    plan_source_value,
    AVG(paid_ratio) AS avg_coverage_ratio,
    MIN(paid_ratio) AS min_coverage_ratio,
    MAX(paid_ratio) AS max_coverage_ratio
  FROM (
    SELECT 
      ppp.plan_source_value,
      c.cost_event_id,
      MAX(CASE WHEN c.cost_concept_id = 31980 THEN c.cost ELSE 0 END) AS total_cost,
      MAX(CASE WHEN c.cost_concept_id = 31981 THEN c.cost ELSE 0 END) AS paid_by_payer,
      CASE 
        WHEN MAX(CASE WHEN c.cost_concept_id = 31980 THEN c.cost ELSE 0 END) > 0
        THEN MAX(CASE WHEN c.cost_concept_id = 31981 THEN c.cost ELSE 0 END) / 
             MAX(CASE WHEN c.cost_concept_id = 31980 THEN c.cost ELSE 0 END)
        ELSE 0
      END AS paid_ratio
    FROM main.cost c
    JOIN main.payer_plan_period ppp ON c.payer_plan_period_id = ppp.payer_plan_period_id
    WHERE c.cost_concept_id IN (31980, 31981)
    GROUP BY ppp.plan_source_value, c.cost_event_id
  )
  WHERE total_cost > 0
  GROUP BY plan_source_value
") |>
  rename_with(tolower)

cli::cli_h3("Payer coverage patterns:")
print(payerCoverage)
```

## Tips for Using Eunomia

### 1. Reproducibility

Always use a seed for consistent results:

```{r reproducibility}
# Set seed for reproducible synthetic data
set.seed(42)

# Inject cost data with specific seed
injectCostData(
  connection = connection,
  cdmDatabaseSchema = "main",
  seed = 42
)
```

### 2. Customizing Cost Generation

You can customize which domains get cost data:

```{r customize-costs}
# Generate costs only for specific domains
injectCostData(
  connection = connection,
  cdmDatabaseSchema = "main",
  costDomains = c("Visit", "Drug", "Procedure"),
  seed = 123
)
```

### 3. Testing Edge Cases

Use Eunomia to test edge cases:

```{r edge-cases}
# Test with empty cohort
DatabaseConnector::executeSql(connection, "
  CREATE TABLE main.empty_cohort AS
  SELECT 
    1 AS cohort_definition_id,
    person_id AS subject_id,
    '2025-01-01' AS cohort_start_date,
    '2025-12-31' AS cohort_end_date
  FROM main.person
  WHERE 1 = 0  -- No results
")

# This should handle gracefully
emptyCohortResult <- tryCatch({
  calculateCostOfCare(
    connection = connection,
    cdmDatabaseSchema = "main",
    cohortDatabaseSchema = "main",
    cohortTable = "empty_cohort",
    cohortId = 1,
    verbose = FALSE
  )
}, error = function(e) {
  cli::cli_alert_warning("Empty cohort handled: {e$message}")
  NULL
})
```

## Clean Up

```{r cleanup}
# Clean up temporary tables
DatabaseConnector::executeSql(connection, "DROP TABLE IF EXISTS main.gi_bleed_cohort")
DatabaseConnector::executeSql(connection, "DROP TABLE IF EXISTS main.drug_cohorts")
DatabaseConnector::executeSql(connection, "DROP TABLE IF EXISTS main.empty_cohort")

# Disconnect
DatabaseConnector::disconnect(connection)
cli::cli_alert_success("Disconnected from Eunomia database")
```

## Summary

This vignette demonstrated:

1. **Setting up Eunomia** with synthetic cost data using `injectCostData()`
2. **Transforming cost tables** to CDM v5.4+ format with `transformCostToCdmV5dot4()`
3. **Exploring synthetic data** to understand its structure and distribution
4. **Running realistic analyses** on the test data
5. **Validating data quality** and patterns
6. **Best practices** for reproducible testing

Eunomia with synthetic cost data provides a safe, reproducible environment for:
- Developing and testing cost analysis code
- Creating examples and documentation
- Training and education
- Validating analysis logic before running on real data