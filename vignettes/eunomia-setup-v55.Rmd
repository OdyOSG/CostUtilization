---
title: "Setting Up Eunomia with CDM v5.5 Cost Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Setting Up Eunomia with CDM v5.5 Cost Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  message = FALSE,
  warning = FALSE,
  eval = FALSE
)
```

## Introduction

This vignette demonstrates how to set up and use the CostUtilization package with Eunomia, OHDSI's synthetic test dataset, specifically for **CDM v5.5**. Since Eunomia doesn't include cost data by default, the package provides helper functions to inject synthetic cost data and transform it to the new CDM v5.5 long format.

## Understanding CDM v5.5 Cost Table Changes

### Key Differences from CDM v5.3/v5.4

The CDM v5.5 COST table introduces significant structural changes:

**Wide Format (CDM ≤ v5.3)**:
```
cost_id | person_id | total_charge | paid_by_payer | paid_by_patient | ...
   1    |    123    |    1000.00   |    800.00     |     200.00      | ...
```

**Long Format (CDM v5.5)**:
```
cost_id | person_id | cost_concept_id | cost_source_value | cost | effective_date | ...
   1    |    123    |      31973      |  "total_charge"   | 1000 | 2023-01-15     | ...
   2    |    123    |      31980      |  "paid_by_payer"  | 800  | 2023-01-15     | ...
   3    |    123    |      31981      | "paid_by_patient" | 200  | 2023-01-15     | ...
```

### New CDM v5.5 Fields

- `effective_date`: When the cost was incurred (replaces event-specific dates)
- `cost_event_field_concept_id`: Links cost to specific clinical event fields
- `billed_date`: When the cost was billed
- `paid_date`: When the cost was actually paid
- `cost`: Single cost value (replaces multiple cost columns)

## Setup

```{r setup}
library(CostUtilization)
library(DatabaseConnector)
library(dplyr)
library(cli)
library(rlang)
library(purrr)

# Check if Eunomia is installed
if (!requireNamespace("Eunomia", quietly = TRUE)) {
  cli::cli_alert_warning("Installing Eunomia package...")
  install.packages("Eunomia")
}

library(Eunomia)
```

## Setting Up Eunomia with CDM v5.5 Cost Data

### Step 1: Connect to Eunomia

```{r connect}
# Get connection details for Eunomia
connectionDetails <- Eunomia::getEunomiaConnectionDetails()

# Connect to the database
connection <- DatabaseConnector::connect(connectionDetails)

# Verify connection
cli::cli_alert_success("Connected to Eunomia database")

# Check available tables
tables <- DatabaseConnector::getTableNames(connection, "main")
cli::cli_h3("Available tables in Eunomia:")
print(sort(tables))
```

### Step 2: Inject Synthetic Cost Data

The `injectCostData` function creates synthetic payer plan periods and wide-format cost records:

```{r inject-cost}
# Inject cost data with default settings
cli::cli_h2("Injecting synthetic cost data")

# The function creates wide-format cost data first
injectCostData(
  connection = connection,
  cdmDatabaseSchema = "main",
  seed = 123  # For reproducibility
)

# Verify wide-format cost table creation
costCount <- DatabaseConnector::querySql(
  connection,
  "SELECT COUNT(*) AS n FROM main.cost"
)
cli::cli_alert_info("Created {costCount$n} wide-format cost records")

# Check payer plan periods
payerCount <- DatabaseConnector::querySql(
  connection,
  "SELECT COUNT(*) AS n FROM main.payer_plan_period"
)
cli::cli_alert_info("Created {payerCount$n} payer plan periods")

# Examine the wide-format structure
wideStructure <- DatabaseConnector::querySql(
  connection,
  "PRAGMA table_info(cost)"
)

cli::cli_h3("Wide-format cost table structure:")
print(wideStructure |> select(name, type))
```

### Step 3: Transform to CDM v5.5 Long Format

This is the key step that transforms the wide-format table to CDM v5.5:

```{r transform-cost}
# Transform cost table to v5.5 long format
cli::cli_h2("Transforming cost table to CDM v5.5 long format")

transformCostToCdmV5dot5(
  connectionDetails = connectionDetails,
  cdmDatabaseSchema = "main",
  createIndexes = TRUE
)

# Verify transformation
longStructure <- DatabaseConnector::querySql(
  connection,
  "PRAGMA table_info(cost)"
)

cli::cli_h3("CDM v5.5 long-format cost table structure:")
print(longStructure |> select(name, type))

# Check that backup was created
tables_after <- DatabaseConnector::getTableNames(connection, "main")
cli::cli_alert_info("Backup table created: {any(grepl('cost_v5_3_backup', tables_after))}")
```

## Exploring the CDM v5.5 Cost Data

### Understanding the Long Format

```{r explore-long-format}
# Examine cost concept distribution
costConcepts <- DatabaseConnector::querySql(connection, "
  SELECT 
    cost_concept_id,
    cost_source_value,
    COUNT(*) AS n_records,
    AVG(cost) AS avg_cost,
    MIN(cost) AS min_cost,
    MAX(cost) AS max_cost
  FROM main.cost
  GROUP BY cost_concept_id, cost_source_value
  ORDER BY n_records DESC
") |>
  rename_with(tolower)

cli::cli_h3("Cost concept distribution in long format:")
print(costConcepts)

# Show the relationship between original wide and new long format
comparisonQuery <- "
WITH wide_sample AS (
  SELECT * FROM main.cost_v5_3_backup LIMIT 1
),
long_sample AS (
  SELECT 
    person_id,
    cost_concept_id,
    cost_source_value,
    cost,
    effective_date
  FROM main.cost 
  WHERE person_id = (SELECT person_id FROM wide_sample)
  ORDER BY cost_concept_id
)
SELECT * FROM long_sample
"

longSample <- DatabaseConnector::querySql(connection, comparisonQuery) |>
  rename_with(tolower)

cli::cli_h3("Example: One wide record becomes multiple long records:")
print(longSample)
```

### Understanding Payer Plans

```{r explore-payers}
# Examine payer plan distribution
payerPlans <- DatabaseConnector::querySql(connection, "
  SELECT 
    payer_source_value,
    plan_source_value,
    COUNT(*) AS n_periods,
    COUNT(DISTINCT person_id) AS n_persons,
    AVG(JULIANDAY(payer_plan_period_end_date) - JULIANDAY(payer_plan_period_start_date)) AS avg_duration_days
  FROM main.payer_plan_period
  GROUP BY payer_source_value, plan_source_value
  ORDER BY n_periods DESC
") |>
  rename_with(tolower)

cli::cli_h3("Payer plan distribution:")
print(payerPlans)

# Check temporal coverage
temporalCoverage <- DatabaseConnector::querySql(connection, "
  SELECT 
    MIN(effective_date) AS earliest_cost,
    MAX(effective_date) AS latest_cost,
    COUNT(DISTINCT DATE(effective_date, 'start of month')) AS n_months,
    COUNT(DISTINCT person_id) AS n_persons_with_costs
  FROM main.cost
  WHERE effective_date IS NOT NULL
") |>
  rename_with(tolower)

cli::cli_h3("Temporal coverage of cost data:")
print(temporalCoverage)
```

### Understanding Cost Distribution

```{r explore-costs}
# Analyze cost distribution by domain and concept
costByDomain <- DatabaseConnector::querySql(connection, "
  SELECT 
    cost_domain_id,
    cost_concept_id,
    cost_source_value,
    COUNT(*) AS n_records,
    COUNT(DISTINCT person_id) AS n_persons,
    AVG(cost) AS avg_cost,
    MEDIAN(cost) AS median_cost,
    MIN(cost) AS min_cost,
    MAX(cost) AS max_cost
  FROM main.cost
  GROUP BY cost_domain_id, cost_concept_id, cost_source_value
  ORDER BY cost_domain_id, n_records DESC
") |>
  rename_with(tolower)

cli::cli_h3("Cost distribution by domain and concept:")
print(costByDomain)

# Compare cost components for the same events
costComparison <- DatabaseConnector::querySql(connection, "
  SELECT 
    person_id,
    visit_occurrence_id,
    effective_date,
    SUM(CASE WHEN cost_concept_id = 31973 THEN cost ELSE 0 END) AS total_charge,
    SUM(CASE WHEN cost_concept_id = 31985 THEN cost ELSE 0 END) AS total_cost,
    SUM(CASE WHEN cost_concept_id = 31980 THEN cost ELSE 0 END) AS paid_by_payer,
    SUM(CASE WHEN cost_concept_id = 31981 THEN cost ELSE 0 END) AS paid_by_patient
  FROM main.cost
  WHERE visit_occurrence_id IS NOT NULL
  GROUP BY person_id, visit_occurrence_id, effective_date
  HAVING COUNT(DISTINCT cost_concept_id) > 1
  LIMIT 10
") |>
  rename_with(tolower)

cli::cli_h3("Cost components for the same events (reconstructed from long format):")
print(costComparison)
```

## Running Cost Analyses on CDM v5.5 Data

### Example 1: Basic Cohort Cost Analysis

```{r basic-analysis}
# Create a cohort of patients with gastrointestinal bleeding
DatabaseConnector::executeSql(connection, "
  CREATE TABLE main.gi_bleed_cohort AS
  SELECT DISTINCT
    1 AS cohort_definition_id,
    person_id AS subject_id,
    condition_start_date AS cohort_start_date,
    COALESCE(condition_end_date, DATE(condition_start_date, '+30 days')) AS cohort_end_date
  FROM main.condition_occurrence
  WHERE condition_concept_id IN (192671, 4112343)  -- GI bleeding concepts
")

cohortSize <- DatabaseConnector::querySql(
  connection,
  "SELECT COUNT(DISTINCT subject_id) AS n FROM main.gi_bleed_cohort"
)
cli::cli_alert_info("Created GI bleeding cohort with {cohortSize$n} patients")

# Analyze costs using the new CDM v5.5 approach
costSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = -30L,   # 30 days before
  endOffsetDays = 90L,      # 90 days after
  costConceptId = 31973L    # Total charge
)

giBleedCosts <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "gi_bleed_cohort",
  cohortId = 1,
  costOfCareSettings = costSettings,
  verbose = TRUE
)

cli::cli_h3("GI Bleeding Cost Analysis Results:")
print(giBleedCosts$results)
```

### Example 2: Comparing Different Cost Types

The long format makes it easy to analyze different cost components:

```{r cost-types}
# Define cost types with their concept IDs
costTypes <- tibble(
  costType = c("total_charge", "total_cost", "paid_by_payer", "paid_by_patient"),
  conceptId = c(31973L, 31985L, 31980L, 31981L),
  description = c(
    "Total charges billed",
    "Total cost incurred", 
    "Amount paid by insurance",
    "Amount paid by patient"
  )
)

# Analyze each cost type
costTypeResults <- costTypes |>
  pmap_dfr(function(costType, conceptId, description) {
    
    settings <- createCostOfCareSettings(
      anchorCol = "cohort_start_date",
      startOffsetDays = 0L,
      endOffsetDays = 180L,
      costConceptId = conceptId
    )
    
    result <- calculateCostOfCare(
      connection = connection,
      cdmDatabaseSchema = "main",
      cohortDatabaseSchema = "main",
      cohortTable = "gi_bleed_cohort",
      cohortId = 1,
      costOfCareSettings = settings,
      verbose = FALSE
    )
    
    result$results |>
      mutate(
        costType = costType,
        conceptId = conceptId,
        description = description
      )
  })

cli::cli_h3("Cost analysis by cost type:")
print(costTypeResults |> select(costType, description, total_cost, cost_pppm))

# Visualize cost breakdown
library(ggplot2)

costTypeResults |>
  ggplot(aes(x = reorder(costType, total_cost), y = total_cost, fill = costType)) +
  geom_bar(stat = "identity") +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "GI Bleeding Costs by Payment Type (CDM v5.5)",
    x = "Cost Type",
    y = "Total Cost ($)",
    caption = "Based on CDM v5.5 long-format cost table"
  ) +
  theme_minimal() +
  theme(legend.position = "none") +
  coord_flip()
```

### Example 3: Event-Specific Costs with Filters

```{r event-costs}
# Define event filters for GI-related procedures and medications
giEventFilters <- list(
  list(
    name = "GI Procedures",
    domain = "Procedure",
    conceptIds = c(4301351L, 4142875L, 4143316L)  # Endoscopy procedures
  ),
  list(
    name = "GI Medications", 
    domain = "Drug",
    conceptIds = c(923645L, 19059410L, 40165636L)  # PPIs, H2 blockers
  ),
  list(
    name = "GI Labs",
    domain = "Measurement",
    conceptIds = c(3016723L, 3013721L)  # Hemoglobin, hematocrit
  )
)

# Create settings with event filters
eventSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = -7L,
  endOffsetDays = 30L,
  eventFilters = giEventFilters,
  costConceptId = 31973L  # Total charge
)

# Analyze GI-specific costs
giSpecificCosts <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "gi_bleed_cohort",
  cohortId = 1,
  costOfCareSettings = eventSettings,
  verbose = TRUE
)

cli::cli_h3("GI-Specific Cost Results:")
print(giSpecificCosts$results)

cli::cli_h3("Diagnostic Information:")
print(giSpecificCosts$diagnostics)
```

## Validating CDM v5.5 Data Quality

### Check Data Completeness and Consistency

```{r validate-data}
# Verify cost data completeness
costCompleteness <- DatabaseConnector::querySql(connection, "
  SELECT 
    'Total Records' AS metric,
    COUNT(*) AS value
  FROM main.cost
  UNION ALL
  SELECT 
    'Records with NULL cost',
    COUNT(*)
  FROM main.cost
  WHERE cost IS NULL
  UNION ALL
  SELECT 
    'Records with zero cost',
    COUNT(*)
  FROM main.cost
  WHERE cost = 0
  UNION ALL
  SELECT 
    'Unique persons with costs',
    COUNT(DISTINCT person_id)
  FROM main.cost
  UNION ALL
  SELECT 
    'Unique cost events',
    COUNT(DISTINCT COALESCE(cost_event_id, 0) || '-' || COALESCE(cost_domain_id, 'NULL'))
  FROM main.cost
  UNION ALL
  SELECT 
    'Records with effective_date',
    COUNT(*)
  FROM main.cost
  WHERE effective_date IS NOT NULL
") |>
  rename_with(tolower)

cli::cli_h3("CDM v5.5 cost data quality metrics:")
print(costCompleteness)

# Validate cost concept usage
conceptValidation <- DatabaseConnector::querySql(connection, "
  SELECT 
    cost_concept_id,
    cost_source_value,
    COUNT(*) AS n_records,
    COUNT(DISTINCT person_id) AS n_persons,
    CASE 
      WHEN cost_concept_id IN (31973, 31985, 31980, 31981, 31974, 31975, 31976, 31979) 
      THEN 'Valid OMOP Concept'
      ELSE 'Non-standard Concept'
    END AS concept_status
  FROM main.cost
  GROUP BY cost_concept_id, cost_source_value
  ORDER BY concept_status, n_records DESC
") |>
  rename_with(tolower)

cli::cli_h3("Cost concept validation:")
print(conceptValidation)
```

### Verify Realistic Cost Patterns

```{r verify-patterns}
# Check that cost relationships make sense
costRelationships <- DatabaseConnector::querySql(connection, "
WITH cost_pivot AS (
  SELECT 
    person_id,
    visit_occurrence_id,
    effective_date,
    MAX(CASE WHEN cost_concept_id = 31973 THEN cost END) AS total_charge,
    MAX(CASE WHEN cost_concept_id = 31985 THEN cost END) AS total_cost,
    MAX(CASE WHEN cost_concept_id = 31980 THEN cost END) AS paid_by_payer,
    MAX(CASE WHEN cost_concept_id = 31981 THEN cost END) AS paid_by_patient
  FROM main.cost
  WHERE visit_occurrence_id IS NOT NULL
  GROUP BY person_id, visit_occurrence_id, effective_date
  HAVING COUNT(DISTINCT cost_concept_id) >= 2
)
SELECT 
  COUNT(*) AS n_events,
  AVG(CASE WHEN total_charge >= total_cost THEN 1.0 ELSE 0.0 END) AS pct_charge_gte_cost,
  AVG(CASE WHEN (paid_by_payer + paid_by_patient) <= total_cost THEN 1.0 ELSE 0.0 END) AS pct_payments_lte_cost,
  AVG(total_charge) AS avg_total_charge,
  AVG(total_cost) AS avg_total_cost,
  AVG(paid_by_payer + paid_by_patient) AS avg_total_paid
FROM cost_pivot
WHERE total_charge IS NOT NULL AND total_cost IS NOT NULL
") |>
  rename_with(tolower)

cli::cli_h3("Cost relationship validation:")
print(costRelationships)

# Check temporal consistency
temporalConsistency <- DatabaseConnector::querySql(connection, "
  SELECT 
    COUNT(*) AS total_records,
    COUNT(effective_date) AS records_with_effective_date,
    COUNT(incurred_date) AS records_with_incurred_date,
    COUNT(billed_date) AS records_with_billed_date,
    COUNT(paid_date) AS records_with_paid_date,
    AVG(CASE WHEN effective_date IS NOT NULL AND incurred_date IS NOT NULL 
             AND effective_date = incurred_date THEN 1.0 ELSE 0.0 END) AS pct_effective_eq_incurred
  FROM main.cost
") |>
  rename_with(tolower)

cli::cli_h3("Temporal field consistency:")
print(temporalConsistency)
```

## Best Practices for CDM v5.5

### 1. Always Use the Transformation Function

```{r best-practices-transform}
# Always transform wide format to CDM v5.5 long format
# This ensures compatibility with the analysis functions

# ✅ Correct approach
transformCostToCdmV5dot5(connectionDetails, cdmDatabaseSchema = "main")

# ❌ Don't try to work with wide format directly
# The analysis functions expect CDM v5.5 long format
```

### 2. Specify Cost Concepts Explicitly

```{r best-practices-concepts}
# ✅ Be explicit about which cost concept you're analyzing
settings_charge <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = 0L,
  endOffsetDays = 365L,
  costConceptId = 31973L  # Total charge - be explicit!
)

settings_cost <- createCostOfCareSettings(
  anchorCol = "cohort_start_date", 
  startOffsetDays = 0L,
  endOffsetDays = 365L,
  costConceptId = 31985L  # Total cost - different from charge!
)

# ❌ Don't rely on defaults without understanding what they mean
```

### 3. Validate Your Data

```{r best-practices-validate}
# ✅ Always check data quality after transformation
validateCostData <- function(connection, schema = "main") {
  
  # Check for required fields
  required_check <- DatabaseConnector::querySql(connection, glue::glue("
    SELECT 
      COUNT(*) AS total_records,
      COUNT(cost_id) AS records_with_cost_id,
      COUNT(person_id) AS records_with_person_id,
      COUNT(effective_date) AS records_with_effective_date,
      COUNT(cost_concept_id) AS records_with_cost_concept_id,
      COUNT(cost) AS records_with_cost_value
    FROM {schema}.cost
  "))
  
  # Check concept distribution
  concept_check <- DatabaseConnector::querySql(connection, glue::glue("
    SELECT 
      cost_concept_id,
      COUNT(*) AS n_records
    FROM {schema}.cost
    GROUP BY cost_concept_id
    ORDER BY n_records DESC
  "))
  
  return(list(
    required_fields = required_check,
    concept_distribution = concept_check
  ))
}

# Run validation
validation_results <- validateCostData(connection)
print(validation_results)
```

## Clean Up

```{r cleanup}
# Clean up temporary tables
DatabaseConnector::executeSql(connection, "DROP TABLE IF EXISTS main.gi_bleed_cohort")

# Disconnect
DatabaseConnector::disconnect(connection)
cli::cli_alert_success("Disconnected from Eunomia database")
```

## Summary

This vignette demonstrated:

1. **CDM v5.5 setup** - Using `transformCostToCdmV5dot5()` to create the new long-format cost table
2. **Data exploration** - Understanding the structure and content of CDM v5.5 cost data
3. **Quality validation** - Checking data completeness and consistency
4. **Analysis examples** - Running cost analyses with the new format
5. **Best practices** - Guidelines for working with CDM v5.5 cost data

### Key Takeaways

- **CDM v5.5 uses a long format** where each cost component is a separate row
- **New temporal fields** provide better traceability of cost timing
- **Explicit cost concepts** make analyses more precise and reproducible
- **The transformation function** handles the complex mapping from wide to long format
- **Data validation** is crucial to ensure quality after transformation

The CDM v5.5 approach provides a more robust, standardized foundation for healthcare cost analysis while maintaining compatibility with existing OHDSI tools and workflows.