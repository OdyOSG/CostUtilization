---
title: "Getting Started with CostUtilization and CDM v5.5"
author: "CostUtilization Development Team"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Getting Started with CostUtilization and CDM v5.5}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE,
  eval = FALSE
)
```

# Introduction

The `CostUtilization` package provides a comprehensive framework for analyzing healthcare costs and resource utilization using OMOP Common Data Model (CDM) databases. **This version is specifically designed for CDM v5.5** with enhanced support for the new long-format COST table structure.

## What's New in CDM v5.5

### Enhanced Cost Table Structure

CDM v5.5 introduces a **long-format COST table** that provides better traceability and analytical flexibility compared to the previous wide format:

**Previous (Wide Format)**:
```
cost_id | person_id | total_charge | paid_by_payer | paid_by_patient
   1    |    123    |    1000.00   |    800.00     |     200.00
```

**CDM v5.5 (Long Format)**:
```
cost_id | person_id | cost_concept_id | cost_source_value | cost | effective_date
   1    |    123    |      31973      |  "total_charge"   | 1000 | 2023-01-15
   2    |    123    |      31980      |  "paid_by_payer"  | 800  | 2023-01-15  
   3    |    123    |      31981      | "paid_by_patient" | 200  | 2023-01-15
```

### New Temporal Fields

- `effective_date`: When the cost was incurred (required)
- `billed_date`: When the cost was billed  
- `paid_date`: When the cost was actually paid
- `incurred_date`: When the cost was incurred (alternative to effective_date)
- `cost_event_field_concept_id`: Links cost to specific clinical event fields

### Enhanced Visit Detail Support

The package now fully supports `VISIT_DETAIL` for micro-costing analysis, allowing you to:

- Analyze costs at the line-item level within visits
- Link costs to specific procedures, measurements, or other clinical events
- Perform granular health economic outcomes research (HEOR)

## Installation

```{r install, eval=FALSE}
# Install from GitHub (devv5 branch)
remotes::install_github("OHDSI/CostUtilization", ref = "devv5")
```

## Key Features

- **CDM v5.5 Compatibility**: Full support for the new long-format COST table
- **Flexible Time Windows**: Analyze costs across user-defined time windows
- **Granular Event Selection**: Calculate costs based on domains or specific concept sets
- **Advanced Cost Filtering**: Restrict analyses to specific cost types and currencies
- **Multiple Aggregation Levels**: Generate per-patient metrics (PPPM, PPPY, etc.)
- **Modern R Implementation**: Settings-based API with tidyverse integration

# Basic Usage

## Setting Up Your Environment

```{r libraries}
library(CostUtilization)
library(dplyr)
library(DBI)
library(duckdb)
```

## Quick Start with Eunomia

The easiest way to get started is using the synthetic Eunomia dataset:

```{r eunomia-setup}
# Create Eunomia DuckDB database
databaseFile <- getEunomiaDuckDb()
connection <- DBI::dbConnect(duckdb::duckdb(databaseFile))

# Transform to CDM v5.5 format (includes synthetic cost data injection)
connection <- transformCostToCdmV5dot5(connection)
```

## Basic Cost Analysis

### 1. Create Analysis Settings

```{r basic-settings}
# Create basic cost analysis settings
costSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",     # Anchor on cohort start date
  startOffsetDays = -365L,             # 1 year before index
  endOffsetDays = 0L,                  # Up to index date
  costConceptId = 31973L               # Total charge (see concept table below)
)

# View settings
print(costSettings)
```

### 2. Execute the Analysis

```{r basic-analysis}
# Run the cost analysis
results <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main", 
  cohortTable = "cohort",
  cohortId = 1,
  costOfCareSettings = costSettings,
  verbose = TRUE
)

# View results structure
str(results)
```

### 3. Examine Results

```{r examine-results}
# Main results
print(results$results)

# Diagnostic information
print(results$diagnostics)

# Key metrics
results$results |>
  select(
    total_person_years,
    total_cost,
    cost_pppm,           # Per-person-per-month
    cost_pppy,           # Per-person-per-year
    n_persons_with_cost
  )
```

## Understanding Cost Concepts

The package supports all standard OMOP cost concepts:

```{r cost-concepts}
# Standard CDM v5.5 cost concepts
cost_concepts <- tibble::tribble(
  ~concept_id, ~description,           ~source_value,
  31973L,      "Total charge",         "total_charge",
  31985L,      "Total cost",           "total_cost", 
  31980L,      "Paid by payer",        "paid_by_payer",
  31981L,      "Paid by patient",      "paid_by_patient",
  31974L,      "Patient copay",        "paid_patient_copay",
  31975L,      "Patient coinsurance",  "paid_patient_coinsurance", 
  31976L,      "Patient deductible",   "paid_patient_deductible",
  31979L,      "Amount allowed",       "amount_allowed"
)

print(cost_concepts)
```

## Multi-Cost Analysis

Analyze multiple cost types simultaneously using modern R patterns:

```{r multi-cost}
# Analyze multiple cost types
cost_types <- tibble(
  cost_type = c("total_charge", "total_cost", "paid_by_payer", "paid_by_patient"),
  concept_id = c(31973L, 31985L, 31980L, 31981L)
)

# Use purrr to run multiple analyses
multi_results <- cost_types |>
  purrr::pmap_dfr(function(cost_type, concept_id) {
    settings <- createCostOfCareSettings(
      anchorCol = "cohort_start_date",
      startOffsetDays = -365L,
      endOffsetDays = 365L,
      costConceptId = concept_id
    )
    
    calculateCostOfCare(
      connection = connection,
      cdmDatabaseSchema = "main",
      cohortDatabaseSchema = "main",
      cohortTable = "cohort", 
      cohortId = 1,
      costOfCareSettings = settings
    )$results |>
      mutate(cost_type = cost_type)
  })

# View comparative results
multi_results |>
  select(cost_type, total_cost, cost_pppm, cost_pppy) |>
  arrange(desc(total_cost))
```

# Advanced Features

## Time Window Analysis

Analyze costs across different time periods:

```{r time-windows}
# Define multiple time windows
time_windows <- tibble::tribble(
  ~period,        ~start_days, ~end_days,
  "Pre-index",    -365L,       -1L,
  "Index",        0L,          0L, 
  "Post-30",      1L,          30L,
  "Post-90",      31L,         90L,
  "Post-365",     91L,         365L
)

# Analyze each window
window_results <- time_windows |>
  purrr::pmap_dfr(function(period, start_days, end_days) {
    settings <- createCostOfCareSettings(
      anchorCol = "cohort_start_date",
      startOffsetDays = start_days,
      endOffsetDays = end_days,
      costConceptId = 31973L
    )
    
    calculateCostOfCare(
      connection = connection,
      cdmDatabaseSchema = "main",
      cohortDatabaseSchema = "main",
      cohortTable = "cohort",
      cohortId = 1, 
      costOfCareSettings = settings
    )$results |>
      mutate(period = period)
  })

# View results by period
window_results |>
  select(period, total_cost, cost_pppm, n_persons_with_cost) |>
  arrange(match(period, time_windows$period))
```

## Event-Based Filtering

Filter costs to specific clinical events or domains:

```{r event-filtering}
# Define event filters for diabetes-related costs
diabetes_filters <- list(
  list(
    name = "Diabetes Diagnoses",
    domain = "Condition",
    conceptIds = c(201820L, 201826L, 443238L)  # Type 2 diabetes concepts
  ),
  list(
    name = "Diabetes Medications", 
    domain = "Drug",
    conceptIds = c(1503297L, 1502826L, 1502855L)  # Metformin, insulin, etc.
  ),
  list(
    name = "Diabetes Labs",
    domain = "Measurement", 
    conceptIds = c(3004501L, 3003309L)  # HbA1c, glucose
  )
)

# Create settings with event filters
event_settings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = -365L,
  endOffsetDays = 365L,
  eventFilters = diabetes_filters,
  nFilters = 1L,  # Require at least 1 filter to match
  costConceptId = 31973L
)

# Run filtered analysis
filtered_results <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "cohort",
  cohortId = 1,
  costOfCareSettings = event_settings
)

print(filtered_results$results)
```

## Visit Restriction

Restrict analysis to specific visit types:

```{r visit-restriction}
# Restrict to inpatient visits only
inpatient_settings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = -365L,
  endOffsetDays = 365L,
  restrictVisitConceptIds = c(9201L),  # Inpatient visit
  costConceptId = 31973L
)

inpatient_results <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main", 
  cohortDatabaseSchema = "main",
  cohortTable = "cohort",
  cohortId = 1,
  costOfCareSettings = inpatient_settings
)

print(inpatient_results$results)
```

# Micro-Costing with Visit Details

For granular line-item analysis, use micro-costing with visit details:

```{r micro-costing}
# Create settings for micro-costing
micro_settings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = -90L,
  endOffsetDays = 90L,
  eventFilters = diabetes_filters,
  primaryEventFilterName = "Diabetes Diagnoses",  # Primary filter for micro-costing
  microCosting = TRUE,  # Enable micro-costing
  costConceptId = 31973L
)

# Run micro-costing analysis
micro_results <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main", 
  cohortTable = "cohort",
  cohortId = 1,
  costOfCareSettings = micro_settings
)

# Micro-costing provides line-item level detail
print(micro_results$results)
print(micro_results$diagnostics)
```

# Data Visualization

Create visualizations of your cost analysis results:

```{r visualization, eval=FALSE}
library(ggplot2)
library(scales)

# Cost by time period
window_results |>
  mutate(period = factor(period, levels = time_windows$period)) |>
  ggplot(aes(x = period, y = total_cost, fill = period)) +
  geom_col() +
  scale_y_continuous(labels = dollar_format()) +
  labs(
    title = "Healthcare Costs by Time Period",
    subtitle = "CDM v5.5 Long-Format Cost Analysis",
    x = "Time Period",
    y = "Total Cost ($)",
    fill = "Period"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Cost comparison by type
multi_results |>
  ggplot(aes(x = reorder(cost_type, total_cost), y = total_cost, fill = cost_type)) +
  geom_col() +
  coord_flip() +
  scale_y_continuous(labels = dollar_format()) +
  labs(
    title = "Healthcare Costs by Payment Type",
    subtitle = "CDM v5.5 Cost Concept Analysis", 
    x = "Cost Type",
    y = "Total Cost ($)",
    fill = "Cost Type"
  ) +
  theme_minimal()
```

# Best Practices

## 1. Settings Validation

Always validate your settings before running analyses:

```{r validation}
# Settings are automatically validated
tryCatch({
  invalid_settings <- createCostOfCareSettings(
    anchorCol = "invalid_column",  # This will fail validation
    startOffsetDays = 365L,        # End before start
    endOffsetDays = -365L,
    costConceptId = 31973L
  )
}, error = function(e) {
  message("Validation caught error: ", e$message)
})
```

## 2. Connection Management

Use proper connection management:

```{r connection-management}
# Option 1: Pass connection directly
results1 <- calculateCostOfCare(
  connection = connection,  # Direct connection
  # ... other parameters
)

# Option 2: Use connection details (auto-managed)
connectionDetails <- DatabaseConnector::createConnectionDetails(
  dbms = "duckdb",
  server = databaseFile
)

results2 <- calculateCostOfCare(
  connectionDetails = connectionDetails,  # Auto-managed
  # ... other parameters  
)
```

## 3. Error Handling and Diagnostics

Always check diagnostics for data quality issues:

```{r diagnostics}
# Examine diagnostic steps
results$diagnostics |>
  arrange(step_name) |>
  mutate(
    persons_lost = lag(n_persons, default = first(n_persons)) - n_persons,
    pct_remaining = round(100 * n_persons / first(n_persons), 1)
  ) |>
  select(step_name, n_persons, persons_lost, pct_remaining)
```

# Cleanup

```{r cleanup}
# Always disconnect when done
DBI::dbDisconnect(connection, shutdown = TRUE)
```

# Next Steps

- **[Eunomia Setup Guide](eunomia-setup-v55.html)**: Detailed setup instructions
- **[Advanced Cost Analysis](advanced-cost-analysis-v55.html)**: Complex analysis patterns
- **[CPI Adjustment](cpi-adjustment.html)**: Inflation adjustment techniques
- **[Visit Detail Analysis](visit-detail-analysis.html)**: Micro-costing deep dive

# Support

- **GitHub Issues**: [Report bugs or request features](https://github.com/OHDSI/CostUtilization/issues)
- **OHDSI Forums**: [Community support](https://forums.ohdsi.org/)
- **Documentation**: [Package website](https://ohdsi.github.io/CostUtilization/)