---
title: "Getting Started with CostUtilization (CDM v5.5)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with CostUtilization (CDM v5.5)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  message = FALSE,
  warning = FALSE,
  eval = FALSE
)
```

## Introduction

The CostUtilization package provides tools for analyzing healthcare costs and utilization patterns using OMOP CDM data. This vignette demonstrates the basic functionality using the Eunomia test dataset with synthetic cost data, specifically designed for **CDM v5.5** with the new long-format COST table structure.

## Key Changes in CDM v5.5

CDM v5.5 introduces significant improvements to the COST table:

- **Long format**: Each cost component (total_charge, paid_by_payer, etc.) is now a separate row
- **New fields**: `effective_date`, `cost_event_field_concept_id`, `billed_date`, `paid_date`
- **Enhanced traceability**: Better linkage between cost events and clinical events
- **Standardized concepts**: Consistent use of OMOP cost concept IDs

## Setup

First, let's load the required packages and set up our test environment:

```{r setup}
library(CostUtilization)
library(DatabaseConnector)
library(dplyr)
library(ggplot2)
library(cli)
library(rlang)
library(purrr)

# Get connection to Eunomia test database
connectionDetails <- Eunomia::getEunomiaConnectionDetails()
connection <- DatabaseConnector::connect(connectionDetails)

# Inject synthetic cost data for testing
cli::cli_h2("Setting up test data")
injectCostData(
  connection = connection,
  cdmDatabaseSchema = "main",
  seed = 123
)

# Transform to CDM v5.5 format - this is the key difference!
transformCostToCdmV5dot5(
  connectionDetails = connectionDetails,
  cdmDatabaseSchema = "main"
)
```

## Exploring the CDM v5.5 Cost Table Structure

Let's examine the new cost table structure:

```{r explore-v55-structure}
# Check the new cost table structure
costStructure <- DatabaseConnector::querySql(
  connection,
  "PRAGMA table_info(cost)"
) |>
  rename_with(tolower)

cli::cli_h3("CDM v5.5 Cost Table Structure:")
costStructure |>
  select(name, type) |>
  print()

# Examine cost concept distribution
costConcepts <- DatabaseConnector::querySql(connection, "
  SELECT 
    cost_concept_id,
    COUNT(*) AS n_records,
    AVG(cost) AS avg_cost,
    MIN(cost) AS min_cost,
    MAX(cost) AS max_cost
  FROM main.cost
  GROUP BY cost_concept_id
  ORDER BY n_records DESC
") |>
  rename_with(tolower)

cli::cli_h3("Cost concept distribution in long format:")
print(costConcepts)

# Show sample records
sampleCosts <- DatabaseConnector::querySql(connection, "
  SELECT 
    person_id,
    cost_concept_id,
    cost_source_value,
    cost,
    effective_date,
    incurred_date
  FROM main.cost
  LIMIT 10
") |>
  rename_with(tolower)

cli::cli_h3("Sample cost records:")
print(sampleCosts)
```

## Basic Cost Analysis with Settings Object

The new approach uses a settings object for cleaner, more maintainable code:

```{r create-cohort}
# Create a simple cohort of all patients with at least one visit
DatabaseConnector::executeSql(connection, "
  CREATE TABLE main.test_cohort AS
  SELECT DISTINCT
    1 AS cohort_definition_id,
    person_id AS subject_id,
    MIN(visit_start_date) AS cohort_start_date,
    MAX(visit_end_date) AS cohort_end_date
  FROM main.visit_occurrence
  GROUP BY person_id
")

# Check cohort size
cohortCount <- DatabaseConnector::querySql(
  connection, 
  "SELECT COUNT(DISTINCT subject_id) AS n FROM main.test_cohort"
)
cli::cli_alert_info("Created cohort with {cohortCount$n} subjects")
```

Now let's calculate costs using the new settings-based approach:

```{r basic-analysis}
# Create cost analysis settings
costSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = 0L,
  endOffsetDays = 365L,
  costConceptId = 31978L,  # Total charge
  currencyConceptId = 44818668L  # USD
)

# Calculate cost of care for 1 year after cohort start
results <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "test_cohort",
  cohortId = 1,
  costOfCareSettings = costSettings,
  verbose = TRUE
)

# Display results
cli::cli_h3("Cost Analysis Results")
print(results$results)
print(results$diagnostics)
```

## Analysis with Visit Restrictions

You can restrict the analysis to specific visit types using the settings object:

```{r visit-restriction}
# Analyze only inpatient and emergency visits
inpatientEmergencyVisits <- c(
  9201L,  # Inpatient Visit
  9203L   # Emergency Room Visit
)

restrictedSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = 0L,
  endOffsetDays = 365L,
  restrictVisitConceptIds = inpatientEmergencyVisits,
  costConceptId = 31978L
)

resultsRestricted <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "test_cohort",
  cohortId = 1,
  costOfCareSettings = restrictedSettings,
  verbose = TRUE
)

cli::cli_h3("Restricted Visit Analysis Results")
print(resultsRestricted$results)
```

## Event-Based Cost Analysis

You can analyze costs associated with specific clinical events using event filters:

```{r event-filters}
# Define event filters for diabetes-related costs using modern R practices
diabetesFilters <- list(
  list(
    name = "Diabetes Diagnoses",
    domain = "Condition",
    conceptIds = c(201820L, 201826L, 443238L, 442793L)  # Type 2 diabetes
  ),
  list(
    name = "Diabetes Medications",
    domain = "Drug", 
    conceptIds = c(1503297L, 1502826L, 1502855L)  # Metformin, insulin, etc.
  ),
  list(
    name = "Diabetes Labs",
    domain = "Measurement",
    conceptIds = c(3004501L, 3003309L)  # HbA1c, glucose
  )
)

# Create settings with event filters
eventFilterSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = -365L,  # 1 year before
  endOffsetDays = 365L,     # to 1 year after
  eventFilters = diabetesFilters,
  costConceptId = 31978L
)

resultsFiltered <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "test_cohort",
  cohortId = 1,
  costOfCareSettings = eventFilterSettings,
  verbose = TRUE
)

cli::cli_h3("Diabetes-Related Cost Analysis Results")
print(resultsFiltered$results)
```

## Micro-Costing Analysis

For detailed cost analysis at the visit detail level:

```{r micro-costing}
# First, ensure visit_detail table exists and has data
# (In real CDM, this would already exist)
DatabaseConnector::executeSql(connection, "
  CREATE TABLE IF NOT EXISTS main.visit_detail AS
  SELECT 
    ROW_NUMBER() OVER () AS visit_detail_id,
    person_id,
    visit_occurrence_id,
    9201 AS visit_detail_concept_id,
    visit_start_date AS visit_detail_start_date,
    visit_end_date AS visit_detail_end_date
  FROM main.visit_occurrence
")

# Create micro-costing settings
microCostingSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = 0L,
  endOffsetDays = 90L,
  eventFilters = diabetesFilters,
  microCosting = TRUE,
  primaryEventFilterName = "Diabetes Medications",
  costConceptId = 31978L
)

resultsMicro <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "test_cohort",
  cohortId = 1,
  costOfCareSettings = microCostingSettings,
  verbose = TRUE
)

cli::cli_h3("Micro-Costing Analysis Results")
print(resultsMicro$results)
```

## Comparing Time Windows with purrr

Let's analyze costs across different time windows using modern R practices:

```{r time-windows}
# Define time windows using a tibble for clarity
timeWindows <- tibble(
  windowName = c("preCohort", "during", "postCohort"),
  startDays = c(-365L, 0L, 91L),
  endDays = c(-1L, 90L, 365L)
)

# Run analysis for each window using purrr
windowResults <- timeWindows |>
  pmap_dfr(function(windowName, startDays, endDays) {
    
    settings <- createCostOfCareSettings(
      anchorCol = "cohort_start_date",
      startOffsetDays = startDays,
      endOffsetDays = endDays,
      costConceptId = 31978L
    )
    
    result <- calculateCostOfCare(
      connection = connection,
      cdmDatabaseSchema = "main",
      cohortDatabaseSchema = "main",
      cohortTable = "test_cohort",
      cohortId = 1,
      costOfCareSettings = settings,
      verbose = FALSE
    )
    
    result$results |>
      mutate(timeWindow = windowName)
  })

# Display comparative results
cli::cli_h3("Cost Analysis by Time Window")
print(windowResults)

# Visualize results
windowResults |>
  ggplot(aes(x = timeWindow, y = !!sym("cost_pppm"))) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(
    title = "Cost Per Person Per Month by Time Window",
    x = "Time Window",
    y = "Cost PPPM ($)"
  ) +
  theme_minimal()
```

## Analyzing Different Cost Types

CDM v5.5's long format makes it easy to analyze different cost components:

```{r cost-types}
# Define different cost concept IDs
costTypes <- tibble(
  costType = c("total_charge", "total_cost", "paid_by_payer", "paid_by_patient"),
  conceptId = c(31973L, 31985L, 31980L, 31981L)
)

# Analyze each cost type
costTypeResults <- costTypes |>
  pmap_dfr(function(costType, conceptId) {
    
    settings <- createCostOfCareSettings(
      anchorCol = "cohort_start_date",
      startOffsetDays = 0L,
      endOffsetDays = 365L,
      costConceptId = conceptId
    )
    
    result <- calculateCostOfCare(
      connection = connection,
      cdmDatabaseSchema = "main",
      cohortDatabaseSchema = "main",
      cohortTable = "test_cohort",
      cohortId = 1,
      costOfCareSettings = settings,
      verbose = FALSE
    )
    
    result$results |>
      mutate(costType = costType)
  })

# Display results
cli::cli_h3("Cost Analysis by Cost Type")
print(costTypeResults)

# Visualize cost breakdown
costTypeResults |>
  ggplot(aes(x = costType, y = !!sym("total_cost"), fill = costType)) +
  geom_bar(stat = "identity") +
  scale_fill_brewer(palette = "Set2") +
  labs(
    title = "Healthcare Costs by Payment Type (CDM v5.5)",
    x = "Cost Type",
    y = "Total Cost ($)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

## Getting Detailed Results

The new API returns both results and diagnostics:

```{r detailed-results}
# Create comprehensive settings
comprehensiveSettings <- createCostOfCareSettings(
  anchorCol = "cohort_start_date",
  startOffsetDays = 0L,
  endOffsetDays = 365L,
  eventFilters = diabetesFilters,
  costConceptId = 31978L
)

# Get detailed results including diagnostics
detailedResults <- calculateCostOfCare(
  connection = connection,
  cdmDatabaseSchema = "main",
  cohortDatabaseSchema = "main",
  cohortTable = "test_cohort",
  cohortId = 1,
  costOfCareSettings = comprehensiveSettings,
  verbose = TRUE
)

# Examine components
cli::cli_h3("Main Results")
print(detailedResults$results)

cli::cli_h3("Diagnostics")
print(detailedResults$diagnostics)

# Plot diagnostic information using rlang for clean column references
diagPlot <- detailedResults$diagnostics |>
  filter(!!sym("step_name") != "00_initial_cohort") |>
  ggplot(aes(x = !!sym("step_name"), y = !!sym("n_persons"))) +
  geom_bar(stat = "identity", fill = "darkgreen") +
  labs(
    title = "Patient Flow Through Analysis Steps",
    x = "Analysis Step",
    y = "Number of Persons"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(diagPlot)
```

## Clean Up

Don't forget to disconnect from the database when finished:

```{r cleanup}
# Clean up test cohort
DatabaseConnector::executeSql(connection, "DROP TABLE IF EXISTS main.test_cohort")

# Disconnect
DatabaseConnector::disconnect(connection)
cli::cli_alert_success("Disconnected from database")
```

## Summary

This vignette demonstrated the key features of CostUtilization with **CDM v5.5**:

1. **CDM v5.5 compatibility** - Using `transformCostToCdmV5dot5()` for the new long-format cost table
2. **Settings-based API** - Using `createCostOfCareSettings()` for cleaner, more maintainable code
3. **Modern R practices** - Leveraging `rlang`, `purrr`, and `dplyr` for efficient data manipulation
4. **Multiple cost types** - Analyzing different cost components (charges, payments, etc.)
5. **Event filtering** - Focusing on specific clinical events
6. **Micro-costing** - Detailed analysis at the visit detail level
7. **Time window comparisons** - Analyzing costs across different time periods
8. **Comprehensive diagnostics** - Understanding patient flow and data quality

The new CDM v5.5 approach provides:
- **Better traceability** between costs and clinical events
- **More granular analysis** with separate rows for each cost component
- **Enhanced temporal precision** with effective, incurred, billed, and paid dates
- **Standardized cost concepts** for consistent analysis across databases

The CostUtilization package provides a flexible, modern framework for healthcare cost analysis that scales from simple cohort characterization to complex health economics research.